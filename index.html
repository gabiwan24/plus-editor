<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endloses Raster Configurator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --size: 30px;            
            --thickness: 3px;        
            --grid-size: 100px;
            --col-count: 11; 
            --plus-color: #ffffff;
            --bg-color-1: #1500FF;
            --bg-color-2: #000000;
            --bg-grad-angle: 225deg; 
            --bg-image-url: none;
            --bg-x: 0px;
            --bg-y: 0px;
            --bg-scale: 1;
            --bg-opacity: 1;
            --bg-blend: normal;
            --bg-filter: none; /* NEU für Monochrom */
            --brush-size: 100px;
            --brush-x: -9999px;
            --brush-y: -9999px;
        }

        body { overflow: hidden; user-select: none; }
        main { position: relative; background: var(--bg-color-1); overflow: hidden; }
        main.has-gradient { background: linear-gradient(var(--bg-grad-angle), var(--bg-color-1), var(--bg-color-2)); }

        #bg-layer { 
            position: absolute; inset: 0; 
            display: flex; align-items: center; justify-content: center; 
            pointer-events: none; 
        }
        
        #bg-image-element { 
            display: none; 
            transform: translate(var(--bg-x), var(--bg-y)) scale(var(--bg-scale)); 
            transform-origin: center center; 
            max-width: none; 
            opacity: var(--bg-opacity); 
            mix-blend-mode: var(--bg-blend);
            filter: var(--bg-filter); /* Filter anwenden */
        }

        #grid-container {
            position: relative; z-index: 10; display: grid;
            grid-template-columns: repeat(var(--col-count), var(--grid-size));
            grid-auto-rows: var(--grid-size);
            gap: 0px;
            justify-content: center; align-content: center; justify-items: center; align-items: center;
            width: auto; height: auto; pointer-events: none; 
        }

        #ui-layer { position: absolute; inset: 0; z-index: 40; pointer-events: none; }
        #brush-cursor {
            position: absolute; left: 0; top: 0; width: var(--brush-size); height: var(--brush-size);
            border: 1px dashed rgba(255,255,255,0.8); background: rgba(255,255,255,0.1); border-radius: 50%;
            transform: translate(calc(var(--brush-x) - 50%), calc(var(--brush-y) - 50%));
            pointer-events: none; display: none; z-index: 50;
        }
        #grad-line-svg { position: absolute; inset: 0; width: 100%; height: 100%; display: none; }
        #drop-overlay { display: none; position: absolute; inset: 0; background: rgba(255, 255, 255, 0.5); border: 4px dashed #fff; z-index: 60; align-items: center; justify-content: center; font-size: 2rem; color: #fff; font-weight: bold; pointer-events: none; }

        .plus-shape {
            position: relative; display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
            --local-scale: 1; --th-multi: 1;
            width: calc(var(--size) * var(--local-scale));
            height: calc(var(--size) * var(--local-scale));
        }
        
        .bar-h, .bar-v { position: absolute; background-color: var(--plus-color); }
        .bar-h { width: 100%; height: calc(var(--thickness) * var(--th-multi) * var(--local-scale)); }
        .bar-v { height: 100%; width: calc(var(--thickness) * var(--th-multi) * var(--local-scale)); }
        
        .text-alert { color: #dc2626; font-weight: 700; }
        main.is-editing-bg { cursor: move; cursor: grab; } main.is-editing-bg:active { cursor: grabbing; }
        main.is-editing-grad { cursor: crosshair; } main.is-painting { cursor: none; }
        .disabled-control { opacity: 0.4; pointer-events: none; filter: grayscale(1); }
        .tool-btn.active { background-color: #2563EB; color: white; border-color: #2563EB; }

        #sidebar { transition: transform 0.3s ease, width 0.3s ease, min-width 0.3s ease; will-change: width, transform; }
        #sidebar.collapsed { width: 0 !important; min-width: 0 !important; transform: translateX(-100%); overflow: hidden; border: none; }
        @media (min-aspect-ratio: 1/1) { #sidebar { width: 10%; min-width: 200px; } }
        
        #btn-toggle-menu { position: absolute; top: 10px; left: 10px; z-index: 70; background: white; padding: 6px; border-radius: 6px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); cursor: pointer; transition: left 0.3s ease; }
        #sidebar.collapsed + main #btn-toggle-menu svg { transform: rotate(180deg); }

        #sidebar-content::-webkit-scrollbar { width: 4px; }
        #sidebar-content::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 2px; }
        #sidebar-content::-webkit-scrollbar-track { background: transparent; }
    </style>
</head>
<body class="flex w-screen h-screen bg-gray-50 font-sans text-gray-800 text-xs">

    <aside id="sidebar" class="w-1/5 min-w-[240px] bg-white border-r border-gray-200 flex flex-col z-20 shadow-2xl relative h-full">
        <!-- Header -->
        <div class="px-4 py-3 border-b border-gray-100 flex justify-between items-center shrink-0">
            <div><h1 class="text-sm font-bold text-gray-900 leading-tight">Configurator</h1><p class="text-[10px] text-gray-400">v15 Mono</p></div>
            <button id="btn-close-sidebar" class="text-gray-400 hover:text-gray-700"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg></button>
        </div>

        <div id="sidebar-content" class="flex-1 px-4 py-2 overflow-y-auto space-y-3">
            
            <!-- Basis Raster -->
            <div class="space-y-2">
                <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Basis Raster</h2>
                <div class="grid grid-cols-[60px_1fr] gap-2 items-center">
                    <label class="text-[10px] font-medium text-gray-600">Größe</label>
                    <input type="range" id="input-size" min="10" max="300" value="30" class="h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </div>
                <div class="grid grid-cols-[60px_1fr] gap-2 items-center">
                    <label class="text-[10px] font-medium text-gray-600">Dicke</label>
                    <input type="range" id="input-thickness" min="1" max="100" value="10" class="h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </div>
                <div class="grid grid-cols-[60px_1fr] gap-2 items-center">
                    <label class="text-[10px] font-medium text-gray-600">Raster</label>
                    <input type="range" id="input-spacing" min="20" max="250" value="100" class="h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-emerald-600">
                </div>
                <div class="flex justify-between text-[10px] text-gray-400 font-mono pt-1">
                    <span id="val-size">30px</span>
                    <span id="val-thickness-percent">10%</span>
                    <span id="val-spacing">100px</span>
                </div>
            </div>

            <div class="h-px bg-gray-100"></div>

            <!-- Animation -->
            <div class="space-y-2">
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-2">
                        <input type="checkbox" id="check-animation" class="w-3 h-3 text-orange-500 rounded border-gray-300 focus:ring-orange-500">
                        <label for="check-animation" class="text-[10px] font-bold text-gray-600 uppercase tracking-wider cursor-pointer">Animation</label>
                    </div>
                </div>
                
                <div id="anim-controls" class="space-y-1.5 hidden pl-2 border-l-2 border-orange-100">
                    <div class="grid grid-cols-[60px_1fr] gap-2 items-center">
                        <label class="text-[10px] text-gray-500">Intensität</label>
                        <input type="range" id="input-anim-intensity" min="0" max="100" value="50" class="h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-orange-500">
                    </div>
                    <div class="grid grid-cols-[60px_1fr] gap-2 items-center">
                        <label class="text-[10px] text-gray-500">Zufall</label>
                        <input type="range" id="input-anim-random" min="0" max="100" value="20" class="h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-orange-500">
                    </div>
                    <div class="grid grid-cols-[60px_1fr] gap-2 items-center">
                        <label class="text-[10px] text-gray-500">Tempo</label>
                        <input type="range" id="input-anim-speed" min="1" max="50" value="15" class="h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-orange-500">
                    </div>
                </div>
            </div>

            <div class="h-px bg-gray-100"></div>

            <!-- Hintergrund Farbe -->
            <div class="space-y-2">
                <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Farbe & Verlauf</h2>
                <div class="flex items-center gap-2">
                    <input type="color" id="input-color-1" value="#1500FF" class="w-6 h-6 rounded border-0 cursor-pointer p-0 bg-transparent flex-shrink-0">
                    <div id="color-2-container" class="hidden flex items-center gap-2">
                        <span class="text-gray-300">→</span>
                        <input type="color" id="input-color-2" value="#000000" class="w-6 h-6 rounded border-0 cursor-pointer p-0 bg-transparent flex-shrink-0">
                    </div>
                    <div class="flex-1"></div>
                    <div class="flex items-center space-x-2">
                        <input type="checkbox" id="check-gradient" class="w-3 h-3 text-purple-600 rounded border-gray-300">
                        <label for="check-gradient" class="text-[10px] text-gray-500 cursor-pointer">Verlauf</label>
                    </div>
                </div>
                <div id="gradient-edit-container" class="hidden flex justify-end">
                    <div class="flex items-center space-x-1">
                        <input type="checkbox" id="check-grad-edit" class="w-3 h-3 text-purple-600 rounded border-gray-300">
                        <label for="check-grad-edit" class="text-[10px] text-gray-500 cursor-pointer">Richtung ändern</label>
                    </div>
                </div>
            </div>

            <div class="h-px bg-gray-100"></div>

            <!-- Hintergrund Bild -->
            <div class="space-y-2">
                <div class="flex justify-between items-center">
                    <h2 class="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Bild (Drag&Drop)</h2>
                    <div class="flex items-center space-x-1">
                        <input type="checkbox" id="check-bg-edit" disabled class="w-3 h-3 text-blue-600 rounded border-gray-300 disabled:opacity-50">
                        <!-- Renamed "Move" to "Edit" -->
                        <label id="label-bg-edit" for="check-bg-edit" class="text-[10px] text-gray-500 cursor-pointer opacity-50">Edit</label>
                    </div>
                </div>
                
                <div id="bg-controls" class="space-y-1.5 opacity-50 pointer-events-none transition-opacity">
                    <div class="grid grid-cols-[60px_1fr] gap-2 items-center">
                        <label class="text-[10px] text-gray-500">Zoom</label>
                        <input type="range" id="input-bg-scale" min="0.1" max="5" step="0.1" value="1" class="h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-purple-600">
                    </div>
                    <div class="grid grid-cols-[60px_1fr] gap-2 items-center">
                        <label class="text-[10px] text-gray-500">Opazität</label>
                        <input type="range" id="input-bg-opacity" min="0" max="100" value="100" class="h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-pink-600">
                    </div>
                    <!-- Layout Update für Monochrom und Multiplizieren -->
                    <div class="flex items-center justify-between pt-1">
                        <div class="flex items-center space-x-1">
                            <input type="checkbox" id="check-bg-mono" class="w-3 h-3 text-gray-600 rounded border-gray-300 focus:ring-gray-500">
                            <label for="check-bg-mono" class="text-[10px] text-gray-500 cursor-pointer">Monochrom</label>
                        </div>
                        <div class="flex items-center space-x-1">
                            <input type="checkbox" id="check-bg-multiply" class="w-3 h-3 text-pink-600 rounded border-gray-300 focus:ring-pink-500">
                            <label for="check-bg-multiply" class="text-[10px] text-gray-500 cursor-pointer">Multiplizieren</label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="h-px bg-gray-100"></div>

            <!-- Raster Editiermodus -->
            <div class="space-y-2">
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="check-edit-mode" class="w-3 h-3 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                    <label for="check-edit-mode" class="text-[10px] font-bold text-gray-600 uppercase tracking-wider cursor-pointer">Mal-Modus</label>
                </div>
                
                <div id="edit-mode-controls" class="space-y-2 hidden">
                    <div class="flex space-x-3 p-1.5 bg-gray-50 rounded border border-gray-100">
                        <div class="flex items-center space-x-1"><input type="checkbox" id="check-paint-scale" checked class="w-3 h-3 text-blue-600 rounded"><label for="check-paint-scale" class="text-[10px] cursor-pointer">Size</label></div>
                        <div class="flex items-center space-x-1"><input type="checkbox" id="check-paint-thickness" class="w-3 h-3 text-blue-600 rounded"><label for="check-paint-thickness" class="text-[10px] cursor-pointer">Thick</label></div>
                    </div>
                    <div class="grid grid-cols-[60px_1fr] gap-2 items-center">
                        <label class="text-[10px] text-gray-500">Pinsel</label>
                        <input type="range" id="input-brush-size" min="20" max="500" value="100" class="h-1.5 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    </div>
                    <div class="flex gap-1">
                        <button id="btn-tool-plus" class="tool-btn active flex-1 py-1 border border-gray-200 rounded text-xs font-bold hover:bg-gray-100 transition-colors">+</button>
                        <button id="btn-tool-minus" class="tool-btn flex-1 py-1 border border-gray-200 rounded text-xs font-bold hover:bg-gray-100 transition-colors">-</button>
                        <button id="btn-tool-delete" class="tool-btn flex-1 py-1 border border-gray-200 rounded text-xs font-bold hover:bg-gray-100 transition-colors text-red-500">X</button>
                    </div>
                    <div class="flex items-center space-x-1 justify-end">
                        <input type="checkbox" id="check-influence" class="w-3 h-3 text-blue-600 rounded border-gray-300">
                        <label for="check-influence" class="text-[10px] text-gray-500 cursor-pointer">Soft</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer / Export fixed bottom -->
        <div class="p-3 border-t border-gray-200 bg-gray-50 shrink-0 space-y-2">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-1">
                    <input type="checkbox" id="check-export-bg" checked class="w-3 h-3 text-blue-600 rounded border-gray-300">
                    <label for="check-export-bg" class="text-[10px] text-gray-500 cursor-pointer">Mit BG</label>
                </div>
                <span class="text-[9px] text-gray-400" id="stat-items">0 Items</span>
            </div>
            <button id="btn-export" class="w-full py-1.5 px-4 bg-gray-900 hover:bg-gray-800 text-white text-xs font-bold rounded shadow transition-colors">SVG Export</button>
        </div>
    </aside>

    <main id="main-area" class="flex-1 flex items-center justify-center relative">
        <button id="btn-toggle-menu" class="bg-white p-1.5 rounded shadow-sm hover:bg-gray-50 text-gray-500"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button>
        <div id="drop-overlay">Bild hier ablegen</div>
        <div id="bg-layer"><img id="bg-image-element" src="" alt="Background"></div>
        <div id="grid-container"></div>
        <div id="ui-layer">
            <svg id="grad-line-svg"><line id="grad-line-visual" x1="0" y1="0" x2="0" y2="0" stroke="white" stroke-width="2" stroke-dasharray="4" /><circle id="grad-start-point" cx="0" cy="0" r="4" fill="white" /><circle id="grad-end-point" cx="0" cy="0" r="4" fill="white" /></svg>
            <div id="brush-cursor"></div>
        </div>
    </main>

    <script>
        const state = {
            size: 30, thicknessPercent: 10, spacing: 100,
            animation: { active: false, intensity: 0.5, randomness: 0.2, speed: 1.5, startTime: 0 },
            isPaintMode: false, brushSize: 100, activeTool: 'plus', useInfluence: false,
            modifiedCells: new Map(), isPainting: false, paintTargetScale: true, paintTargetThickness: false,
            bgColor1: '#1500FF', bgColor2: '#000000', hasGradient: false, gradientAngle: 225, 
            bgImageSrc: null, bgX: 0, bgY: 0, bgScale: 1, bgMultiply: false, bgOpacity: 100, bgMono: false, // NEU: bgMono
            isEditingBg: false, isEditingGrad: false, isDragging: false, startX: 0, startY: 0, lastMouseX: 0, lastMouseY: 0, mouseX: 0, mouseY: 0 
        };

        const ui = {
            root: document.documentElement, mainArea: document.getElementById('main-area'), dropOverlay: document.getElementById('drop-overlay'), gridContainer: document.getElementById('grid-container'),
            sidebar: document.getElementById('sidebar'), btnToggleMenu: document.getElementById('btn-toggle-menu'), btnCloseSidebar: document.getElementById('btn-close-sidebar'),
            checkAnimation: document.getElementById('check-animation'), animControls: document.getElementById('anim-controls'),
            inputAnimIntensity: document.getElementById('input-anim-intensity'), inputAnimRandom: document.getElementById('input-anim-random'), inputAnimSpeed: document.getElementById('input-anim-speed'),
            checkEditMode: document.getElementById('check-edit-mode'), editModeControls: document.getElementById('edit-mode-controls'),
            checkPaintScale: document.getElementById('check-paint-scale'), checkPaintThickness: document.getElementById('check-paint-thickness'),
            inputBrushSize: document.getElementById('input-brush-size'),
            btnToolPlus: document.getElementById('btn-tool-plus'), btnToolMinus: document.getElementById('btn-tool-minus'), btnToolDelete: document.getElementById('btn-tool-delete'),
            checkInfluence: document.getElementById('check-influence'), brushCursor: document.getElementById('brush-cursor'),
            inputSize: document.getElementById('input-size'), inputThickness: document.getElementById('input-thickness'), inputSpacing: document.getElementById('input-spacing'),
            inputColor1: document.getElementById('input-color-1'), inputColor2: document.getElementById('input-color-2'), 
            color2Container: document.getElementById('color-2-container'), gradientEditContainer: document.getElementById('gradient-edit-container'),
            checkGradient: document.getElementById('check-gradient'), checkGradEdit: document.getElementById('check-grad-edit'),
            gradLineSvg: document.getElementById('grad-line-svg'), gradLineVisual: document.getElementById('grad-line-visual'), gradStartPoint: document.getElementById('grad-start-point'), gradEndPoint: document.getElementById('grad-end-point'),
            checkBgEdit: document.getElementById('check-bg-edit'), labelBgEdit: document.getElementById('label-bg-edit'), bgControls: document.getElementById('bg-controls'),
            inputBgScale: document.getElementById('input-bg-scale'), checkBgMultiply: document.getElementById('check-bg-multiply'), checkBgMono: document.getElementById('check-bg-mono'), inputBgOpacity: document.getElementById('input-bg-opacity'), bgImageElement: document.getElementById('bg-image-element'),
            checkExportBg: document.getElementById('check-export-bg'), btnExport: document.getElementById('btn-export'),
            valSize: document.getElementById('val-size'), valThicknessPercent: document.getElementById('val-thickness-percent'), valSpacing: document.getElementById('val-spacing'), statItems: document.getElementById('stat-items'),
        };

        function simpleHash(x, y) { return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453123 - Math.floor(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453123); }

        function animationLoop() {
            if (!state.animation.active) return;
            const t = (performance.now() * 0.001 * state.animation.speed);
            const children = ui.gridContainer.children;
            const intensity = state.animation.intensity;
            const randomness = state.animation.randomness;

            for (let i = 0; i < children.length; i++) {
                const cell = children[i];
                if (!cell.dataset.x) continue; 
                const lx = parseInt(cell.dataset.x); const ly = parseInt(cell.dataset.y);
                const key = `${lx},${ly}`;

                let baseScale = 1.0; let thMulti = 1.0;
                if (state.modifiedCells.has(key)) {
                    const data = state.modifiedCells.get(key);
                    baseScale = (data && typeof data.scale !== 'undefined') ? data.scale : 1.0;
                    thMulti = (data && typeof data.thMulti !== 'undefined') ? data.thMulti : 1.0;
                }

                const w1 = Math.sin(lx * 0.15 + ly * 0.15 + t);
                const w2 = Math.cos(lx * 0.08 - t * 0.5);
                const w3 = Math.sin(ly * 0.3 + t * 1.5);
                let waveVal = (w1 + w2 + w3) / 3; 
                const noise = simpleHash(lx, ly) * 2 - 1; 
                
                let finalVal = waveVal * (1 - randomness * 0.8) + noise * (randomness * 0.8);
                const delta = finalVal * intensity * 8.0; 
                
                let animatedScale = baseScale * (1 + delta);
                if (animatedScale < 0) animatedScale = 0;

                cell.style.setProperty('--local-scale', animatedScale.toFixed(3));
                cell.style.setProperty('--th-multi', thMulti);
            }
            requestAnimationFrame(animationLoop);
        }

        function updateVisuals() {
            const absoluteThickness = (state.size * state.thicknessPercent) / 100;
            const activeGridSize = Math.max(state.spacing, state.size);

            ui.root.style.setProperty('--size', `${state.size}px`);
            ui.root.style.setProperty('--thickness', `${absoluteThickness}px`);
            ui.root.style.setProperty('--grid-size', `${activeGridSize}px`);
            ui.root.style.setProperty('--bg-color-1', state.bgColor1);
            ui.root.style.setProperty('--bg-color-2', state.bgColor2);
            ui.root.style.setProperty('--bg-grad-angle', `${state.gradientAngle}deg`);
            ui.root.style.setProperty('--bg-blend', state.bgMultiply ? 'multiply' : 'normal');
            ui.root.style.setProperty('--bg-opacity', state.bgOpacity / 100);
            ui.root.style.setProperty('--bg-filter', state.bgMono ? 'grayscale(100%)' : 'none'); // NEU
            ui.root.style.setProperty('--brush-size', `${state.brushSize}px`);

            if (state.hasGradient) { 
                ui.mainArea.classList.add('has-gradient'); 
                ui.color2Container.classList.remove('hidden');
                ui.gradientEditContainer.classList.remove('hidden');
            } else { 
                ui.mainArea.classList.remove('has-gradient'); 
                ui.color2Container.classList.add('hidden');
                ui.gradientEditContainer.classList.add('hidden');
            }

            ui.valSize.innerText = `${state.size}px`;
            ui.valThicknessPercent.innerText = `${state.thicknessPercent}%`;
            ui.valSpacing.innerText = `${state.spacing}px`;

            if (!state.animation.active) {
                const children = ui.gridContainer.children;
                for(let cell of children) resetCellVisual(cell);
            }
            recalcGridGeometry();
        }

        function resetCellVisual(cell) {
            const key = `${cell.dataset.x},${cell.dataset.y}`;
            let data = { scale: 1.0, thMulti: 1.0 };
            if (state.modifiedCells.has(key)) data = state.modifiedCells.get(key);
            updateCellVisual(cell, data);
        }
        function updateCellVisual(cell, data) {
            cell.style.setProperty('--local-scale', data.scale.toFixed(3));
            cell.style.setProperty('--th-multi', data.thMulti);
        }
        
        function updatePaintLoop() {
            if (state.isPaintMode && state.isPainting) {
                applyBrush(state.mouseX, state.mouseY);
                requestAnimationFrame(updatePaintLoop);
            }
        }
        function applyBrush(mx, my) {
            const activeGridSize = Math.max(state.spacing, state.size);
            const gridRect = ui.gridContainer.getBoundingClientRect();
            const localMx = mx - gridRect.left; const localMy = my - gridRect.top;
            const radius = state.brushSize / 2; const radiusSq = radius * radius;
            const children = ui.gridContainer.children; const growthRate = 0.01; 

            for (let i = 0; i < children.length; i++) {
                const cell = children[i];
                const cx = cell.offsetLeft + (activeGridSize / 2); const cy = cell.offsetTop + (activeGridSize / 2);
                const dx = cx - localMx; const dy = cy - localMy;
                if (dx*dx + dy*dy < radiusSq) {
                    const lx = parseInt(cell.dataset.x); const ly = parseInt(cell.dataset.y);
                    const key = `${lx},${ly}`;
                    let d = state.modifiedCells.get(key) || { scale: 1.0, thMulti: 1.0 };
                    let inf = 1; 
                    if (state.useInfluence) { 
                        inf = 1 - (Math.sqrt(dx*dx + dy*dy) / radius); 
                        if (inf < 0) inf = 0; 
                    }
                    if (state.paintTargetScale) {
                        if (state.activeTool === 'plus') d.scale += growthRate * inf;
                        else if (state.activeTool === 'minus') { d.scale -= growthRate * inf; if(d.scale<0) d.scale=0; }
                        else if (state.activeTool === 'delete') d.scale = state.useInfluence ? d.scale*(1-(0.1*inf)) : 0;
                    }
                    if (state.paintTargetThickness) {
                        if (state.activeTool === 'plus') d.thMulti += growthRate * inf;
                        else if (state.activeTool === 'minus') { d.thMulti -= growthRate * inf; if(d.thMulti<0) d.thMulti=0; }
                        else if (state.activeTool === 'delete') d.thMulti = state.useInfluence ? d.thMulti*(1-(0.1*inf)) : 0;
                    }
                    state.modifiedCells.set(key, {...d});
                    if (!state.animation.active) updateCellVisual(cell, d);
                }
            }
        }

        function recalcGridGeometry() {
            const activeGridSize = Math.max(state.spacing, state.size);
            const w = ui.mainArea.clientWidth || window.innerWidth;
            const h = ui.mainArea.clientHeight || window.innerHeight;
            const cols = Math.ceil((w * 1.2) / activeGridSize) + ((Math.ceil((w * 1.2) / activeGridSize) % 2 === 0) ? 5 : 4);
            const rows = Math.ceil((h * 1.2) / activeGridSize) + ((Math.ceil((h * 1.2) / activeGridSize) % 2 === 0) ? 5 : 4);
            ui.root.style.setProperty('--col-count', cols);
            const total = cols * rows; const safe = Math.min(total, 5000);
            ui.statItems.innerText = safe + " Items";
            if (ui.gridContainer.childElementCount !== safe || ui.gridContainer.dataset.cols != cols) {
                renderGridItems(safe, cols, rows);
                ui.gridContainer.dataset.cols = cols;
            }
        }

        function renderGridItems(count, cols, rows) {
            const frag = document.createDocumentFragment();
            ui.gridContainer.innerHTML = '';
            const cc = Math.floor(cols / 2); const cr = Math.floor(rows / 2);
            for (let i = 0; i < count; i++) {
                const c = i % cols; const r = Math.floor(i / cols);
                const lx = c - cc; const ly = r - cr;
                const div = document.createElement('div');
                div.className = 'plus-shape'; div.dataset.x = lx; div.dataset.y = ly;
                const h = document.createElement('div'); h.className = 'bar-h';
                const v = document.createElement('div'); v.className = 'bar-v';
                div.appendChild(h); div.appendChild(v);
                const key = `${lx},${ly}`;
                if (state.modifiedCells.has(key)) updateCellVisual(div, state.modifiedCells.get(key));
                frag.appendChild(div);
            }
            ui.gridContainer.appendChild(frag);
        }

        // --- Interaction Helper ---
        function updateBgTransform() {
            ui.root.style.setProperty('--bg-x', `${state.bgX}px`);
            ui.root.style.setProperty('--bg-y', `${state.bgY}px`);
            ui.root.style.setProperty('--bg-scale', state.bgScale);
        }

        function updateInteractionStates() {
            if (state.isEditingGrad) {
                ui.mainArea.classList.add('is-editing-grad');
                ui.mainArea.classList.remove('is-editing-bg');
                ui.checkBgEdit.disabled = true;
                if(ui.labelBgEdit) ui.labelBgEdit.classList.add('opacity-50');
            } else {
                ui.mainArea.classList.remove('is-editing-grad');
                if (state.bgImageSrc && !state.isPaintMode) { 
                    ui.checkBgEdit.disabled = false;
                    if(ui.labelBgEdit) ui.labelBgEdit.classList.remove('opacity-50');
                    if (ui.checkBgEdit.checked) {
                        ui.mainArea.classList.add('is-editing-bg');
                        ui.bgControls.classList.remove('opacity-50', 'pointer-events-none');
                        state.isEditingBg = true;
                    }
                }
            }
            if (!state.isEditingGrad && state.isEditingBg && !state.isPaintMode) {
                ui.mainArea.classList.add('is-editing-bg');
            } else if (!state.isEditingGrad) {
                 ui.mainArea.classList.remove('is-editing-bg');
            }
        }
        function deactivateGradientMode() {
            if (state.isEditingGrad) {
                state.isEditingGrad = false;
                ui.checkGradEdit.checked = false;
                updateInteractionStates();
            }
        }

        // Listeners
        ui.checkAnimation.addEventListener('change', e => { state.animation.active = e.target.checked; if(e.target.checked) { ui.animControls.classList.remove('hidden'); animationLoop(); } else { ui.animControls.classList.add('hidden'); updateVisuals(); } });
        ui.inputAnimIntensity.addEventListener('input', e => { state.animation.intensity = parseInt(e.target.value)/100; });
        ui.inputAnimRandom.addEventListener('input', e => { state.animation.randomness = parseInt(e.target.value)/100; });
        ui.inputAnimSpeed.addEventListener('input', e => { state.animation.speed = parseInt(e.target.value)/10; });
        
        ui.checkEditMode.addEventListener('change', e => { state.isPaintMode = e.target.checked; if(e.target.checked) { ui.editModeControls.classList.remove('hidden'); ui.mainArea.classList.add('is-painting'); ui.brushCursor.style.display='block'; ui.checkBgEdit.checked=false; ui.checkGradEdit.checked=false; state.isEditingBg=false; state.isEditingGrad=false; } else { ui.editModeControls.classList.add('hidden'); ui.mainArea.classList.remove('is-painting'); ui.brushCursor.style.display='none'; } });
        ui.checkPaintScale.addEventListener('change', e => state.paintTargetScale = e.target.checked);
        ui.checkPaintThickness.addEventListener('change', e => state.paintTargetThickness = e.target.checked);
        ui.inputBrushSize.addEventListener('input', e => { state.brushSize = parseInt(e.target.value); updateVisuals(); });
        ui.checkInfluence.addEventListener('change', e => state.useInfluence = e.target.checked);
        
        ui.btnToolPlus.addEventListener('click', () => setTool('plus')); ui.btnToolMinus.addEventListener('click', () => setTool('minus')); ui.btnToolDelete.addEventListener('click', () => setTool('delete'));
        function setTool(t) { state.activeTool = t; ui.btnToolPlus.classList.remove('active'); ui.btnToolMinus.classList.remove('active'); ui.btnToolDelete.classList.remove('active'); if(t==='plus') ui.btnToolPlus.classList.add('active'); if(t==='minus') ui.btnToolMinus.classList.add('active'); if(t==='delete') ui.btnToolDelete.classList.add('active'); }

        ui.inputSize.addEventListener('input', e => { state.size = parseInt(e.target.value); updateVisuals(); });
        ui.inputThickness.addEventListener('input', e => { state.thicknessPercent = parseInt(e.target.value); updateVisuals(); });
        ui.inputSpacing.addEventListener('input', e => { state.spacing = parseInt(e.target.value); updateVisuals(); });
        ui.inputColor1.addEventListener('input', e => { state.bgColor1 = e.target.value; deactivateGradientMode(); updateVisuals(); });
        ui.inputColor2.addEventListener('input', e => { state.bgColor2 = e.target.value; deactivateGradientMode(); updateVisuals(); });
        ui.checkGradient.addEventListener('change', e => { state.hasGradient = e.target.checked; updateVisuals(); });
        
        // Sidebar Toggles
        function toggleSidebar() {
            ui.sidebar.classList.toggle('collapsed');
            setTimeout(recalcGridGeometry, 310);
        }
        ui.btnToggleMenu.addEventListener('click', toggleSidebar);
        ui.btnCloseSidebar.addEventListener('click', toggleSidebar);

        ui.inputBgScale.addEventListener('input', e => { state.bgScale = parseFloat(e.target.value); updateBgTransform(); });
        ui.checkBgMultiply.addEventListener('change', e => { state.bgMultiply = e.target.checked; updateVisuals(); });
        ui.checkBgMono.addEventListener('change', e => { state.bgMono = e.target.checked; updateVisuals(); }); // NEU Listener
        ui.inputBgOpacity.addEventListener('input', e => { state.bgOpacity = parseInt(e.target.value); updateVisuals(); });
        ui.checkGradEdit.addEventListener('change', e => { state.isEditingGrad = e.target.checked; updateInteractionStates(); });
        ui.checkBgEdit.addEventListener('change', e => { 
            state.isEditingBg = e.target.checked; 
            if (e.target.checked) ui.bgControls.classList.remove('opacity-50', 'pointer-events-none'); 
            else ui.bgControls.classList.add('opacity-50', 'pointer-events-none'); 
            updateInteractionStates(); 
        });

        ui.mainArea.addEventListener('pointermove', e => {
            const rect = ui.mainArea.getBoundingClientRect(); state.mouseX = e.clientX; state.mouseY = e.clientY;
            ui.root.style.setProperty('--brush-x', `${e.clientX - rect.left}px`); ui.root.style.setProperty('--brush-y', `${e.clientY - rect.top}px`);
            
            if (!state.isPaintMode && state.isDragging) {
                if (state.isEditingGrad) {
                    const dx = e.clientX - state.startX;
                    const dy = e.clientY - state.startY;
                    const currentRelX = e.clientX - rect.left;
                    const currentRelY = e.clientY - rect.top;
                    ui.gradLineVisual.setAttribute('x2', currentRelX);
                    ui.gradLineVisual.setAttribute('y2', currentRelY);
                    ui.gradEndPoint.setAttribute('cx', currentRelX);
                    ui.gradEndPoint.setAttribute('cy', currentRelY);
                    const rad = Math.atan2(dy, dx);
                    let deg = rad * (180 / Math.PI) + 90; 
                    state.gradientAngle = Math.round(deg);
                    updateVisuals();
                } else if (state.isEditingBg && state.bgImageSrc) {
                    const dx = e.clientX - state.lastMouseX;
                    const dy = e.clientY - state.lastMouseY;
                    state.bgX += dx;
                    state.bgY += dy;
                    state.lastMouseX = e.clientX;
                    state.lastMouseY = e.clientY;
                    updateBgTransform();
                }
            }
        });
        ui.mainArea.addEventListener('pointerdown', e => { 
            if(state.isPaintMode) { 
                state.isPainting=true; updatePaintLoop(); applyBrush(e.clientX, e.clientY); 
            } else {
                state.isDragging = true;
                state.startX = e.clientX;
                state.startY = e.clientY;
                if (state.isEditingGrad) {
                    const rect = ui.mainArea.getBoundingClientRect();
                    const relX = e.clientX - rect.left;
                    const relY = e.clientY - rect.top;
                    ui.gradLineSvg.style.display = 'block';
                    ui.gradLineVisual.setAttribute('x1', relX); ui.gradLineVisual.setAttribute('y1', relY);
                    ui.gradLineVisual.setAttribute('x2', relX); ui.gradLineVisual.setAttribute('y2', relY);
                    ui.gradStartPoint.setAttribute('cx', relX); ui.gradStartPoint.setAttribute('cy', relY);
                    ui.gradEndPoint.setAttribute('cx', relX); ui.gradEndPoint.setAttribute('cy', relY);
                } else if (state.isEditingBg) {
                    state.lastMouseX = e.clientX;
                    state.lastMouseY = e.clientY;
                }
            }
        });
        window.addEventListener('pointerup', () => { 
            state.isDragging = false; 
            state.isPainting = false; 
            if (state.isEditingGrad) ui.gradLineSvg.style.display = 'none';
        });
        window.addEventListener('resize', () => recalcGridGeometry());

        // -- DRAG & DROP --
        let dragCounter = 0;
        function handleDragEnter(e) { e.preventDefault(); e.stopPropagation(); dragCounter++; if (dragCounter > 0) ui.dropOverlay.style.display = 'flex'; }
        function handleDragLeave(e) { e.preventDefault(); e.stopPropagation(); dragCounter--; if (dragCounter <= 0) { ui.dropOverlay.style.display = 'none'; dragCounter = 0; } }
        function handleDragOver(e) { e.preventDefault(); e.stopPropagation(); }
        function handleDrop(e) {
            e.preventDefault(); e.stopPropagation(); dragCounter = 0; ui.dropOverlay.style.display = 'none';
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        state.bgImageSrc = evt.target.result;
                        ui.bgImageElement.src = state.bgImageSrc;
                        ui.bgImageElement.style.display = 'block';
                        const scaleW = ui.mainArea.clientWidth / img.width;
                        const scaleH = ui.mainArea.clientHeight / img.height;
                        const initialScale = Math.max(scaleW, scaleH);
                        state.bgScale = initialScale; state.bgX = 0; state.bgY = 0;
                        ui.inputBgScale.value = initialScale;
                        updateBgTransform();
                        ui.checkBgEdit.disabled = false;
                        if(ui.labelBgEdit) ui.labelBgEdit.classList.remove('opacity-50');
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(files[0]);
            }
        }
        window.addEventListener('dragenter', handleDragEnter);
        window.addEventListener('dragleave', handleDragLeave);
        window.addEventListener('dragover', handleDragOver);
        window.addEventListener('drop', handleDrop);

        ui.btnExport.addEventListener('click', () => {
            const w = ui.mainArea.clientWidth; const h = ui.mainArea.clientHeight;
            const bS = state.size; const bT = (state.size * state.thicknessPercent) / 100;
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`;
            if (ui.checkExportBg.checked) {
                if (state.hasGradient) { svg += `<defs><linearGradient id="g" gradientTransform="rotate(${state.gradientAngle-90}, 0.5, 0.5)"><stop offset="0%" stop-color="${state.bgColor1}"/><stop offset="100%" stop-color="${state.bgColor2}"/></linearGradient></defs><rect width="100%" height="100%" fill="url(#g)"/>`; } 
                else { svg += `<rect width="100%" height="100%" fill="${state.bgColor1}"/>`; }
                if (state.bgImageSrc) {
                    const nw = ui.bgImageElement.naturalWidth; const nh = ui.bgImageElement.naturalHeight;
                    // SVG Style construction
                    let styleStr = "";
                    if (state.bgMultiply) styleStr += "mix-blend-mode: multiply; ";
                    if (state.bgMono) styleStr += "filter: grayscale(100%); ";
                    
                    svg += `<g transform="translate(${w/2 + state.bgX}, ${h/2 + state.bgY}) scale(${state.bgScale})" style="${styleStr}" opacity="${state.bgOpacity/100}"><image href="${state.bgImageSrc}" x="${-nw/2}" y="${-nh/2}" width="${nw}" height="${nh}"/></g>`;
                }
            }
            const ags = Math.max(state.spacing, state.size);
            const sx = Math.ceil((w/2)/ags)+1; const sy = Math.ceil((h/2)/ags)+1;
            svg += `<g fill="#ffffff">`;
            for(let x=-sx; x<=sx; x++) for(let y=-sy; y<=sy; y++) {
                const px = w/2 + x*ags; const py = h/2 + y*ags;
                let s = 1.0; let t = 1.0;
                const k = `${x},${y}`; if(state.modifiedCells.has(k)) { const d=state.modifiedCells.get(k); s=d.scale; t=d.thMulti; }
                if (s > 0.05) {
                    const cS = bS * s; const cT = bT * t * s;
                    svg += `<rect x="${px-cS/2}" y="${py-cT/2}" width="${cS}" height="${cT}"/><rect x="${px-cT/2}" y="${py-cS/2}" width="${cT}" height="${cS}"/>`;
                }
            }
            svg += `</g></svg>`;
            const b = new Blob([svg], {type: 'image/svg+xml'}); const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'raster.svg'; a.click();
        });

        updateVisuals();
    </script>
</body>
</html>
