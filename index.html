<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organischer Halbmond - Animated & Colors</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            /* Hintergrund: Ein tiefer blauer Verlauf */
            background: radial-gradient(circle at center, #001e45 0%, #000510 100%);
            color: #ccfbf1; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            background-color: transparent; 
            touch-action: none; 
        }

        /* Container Wrapper für Stapelung unten links */
        .ui-sidebar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column-reverse; /* Damit das Main Panel unten ist */
            gap: 15px;
            width: 320px;
            z-index: 10;
            pointer-events: none; /* Klicks gehen durch leere Bereiche durch */
        }

        /* Gemeinsamer Style für Panels */
        .panel {
            background: rgba(0, 5, 16, 0.85);
            backdrop-filter: blur(12px);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #083344;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            pointer-events: auto; /* Klicks aktivieren */
        }

        .main-controls {
            max-height: 60vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .color-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid #22d3ee55; /* Etwas hellerer Border um es hervorzuheben */
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            min-height: 24px;
        }

        .row-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .row-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #94a3b8;
            font-family: monospace;
            margin-bottom: 4px;
            width: 100%;
        }

        /* Label ohne width für Flexbox rows */
        .lbl-inline {
            font-size: 0.8rem;
            color: #ccfbf1;
            font-weight: bold;
            font-family: monospace;
            cursor: pointer;
        }
        
        .lbl-sub {
             font-size: 0.7rem; 
             color: #22d3ee;
             cursor: pointer;
        }

        span.value {
            color: #22d3ee; 
            font-weight: bold;
            text-shadow: 0 0 10px rgba(34, 211, 238, 0.4);
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: #1e293b;
            border-radius: 2px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 2px; 
            background: #22d3ee; 
            cursor: pointer;
            transition: transform .1s, box-shadow 0.2s;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.5);
        }
        
        input[type=range]::-webkit-slider-thumb:hover {
            box-shadow: 0 0 15px rgba(34, 211, 238, 0.8);
        }

        input[type=checkbox] {
            accent-color: #22d3ee;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Color Input Styling */
        input[type=color] {
            -webkit-appearance: none;
            border: none;
            width: 100%;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            background: none;
            padding: 0;
            overflow: hidden;
        }
        input[type=color]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type=color]::-webkit-color-swatch {
            border: 1px solid #334155;
            border-radius: 4px;
        }

        button {
            background: linear-gradient(135deg, #06b6d4, #22d3ee);
            color: #000510;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            cursor: pointer;
            transition: filter 0.2s;
            font-family: monospace;
            text-transform: uppercase;
            width: 100%;
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.3);
        }

        button:hover {
            filter: brightness(1.1);
        }

        .divider {
            height: 1px;
            background-color: #1e293b;
            margin: 5px 0;
            width: 100%;
        }
        
        /* Scrollbar styling */
        .main-controls::-webkit-scrollbar {
            width: 6px;
        }
        .main-controls::-webkit-scrollbar-track {
            background: #000510;
        }
        .main-controls::-webkit-scrollbar-thumb {
            background: #1e293b;
            border-radius: 3px;
        }
    </style>
</head>
<body>

    <canvas id="mainCanvas"></canvas>

    <div class="ui-sidebar">
        
        <!-- MAIN CONTROLS (Unten) -->
        <div class="panel main-controls">
            <!-- Rotation -->
            <div class="control-group">
                <label>
                    Rotation
                    <span id="angleVal" class="value">160°</span>
                </label>
                <input type="range" id="angleSlider" min="0" max="360" step="0.1" value="160">
            </div>

            <!-- Sichel Breite -->
            <div class="control-group">
                <label>
                    Sichel-Breite
                    <span id="crescentVal" class="value">0.6</span>
                </label>
                <input type="range" id="crescentSlider" min="40" max="150" value="60">
            </div>

            <!-- Verlaufshärte -->
            <div class="control-group">
                <label>
                    Verlaufshärte
                    <span id="hardnessVal" class="value">50%</span>
                </label>
                <input type="range" id="hardnessSlider" min="0" max="100" value="50">
            </div>

            <!-- Raster Abstand -->
            <div class="control-group">
                <label>
                    Raster-Abstand
                    <span id="spacingVal" class="value">15px</span>
                </label>
                <input type="range" id="spacingSlider" min="10" max="60" value="15">
            </div>

             <!-- Max Größe -->
             <div class="control-group">
                <label>
                    Max. Größe
                    <span id="maxSizeVal" class="value">90%</span>
                </label>
                <input type="range" id="maxSizeSlider" min="10" max="300" value="90">
            </div>

            <!-- Organik / Rauschen -->
            <div class="control-group">
                <label>
                    Organisches Ausfransen
                    <span id="noiseVal" class="value">60%</span>
                </label>
                <input type="range" id="noiseSlider" min="0" max="100" value="60">
            </div>

            <div class="divider"></div>

            <!-- Background Section -->
            <div class="row">
                <label class="lbl-inline">Background</label>
            </div>
            <div class="row">
                <div style="display:flex; align-items:center; gap:8px;">
                    <input type="checkbox" id="bgSphereCheck">
                    <label for="bgSphereCheck" style="margin:0; font-size:0.7rem; color:#94a3b8; width:auto; cursor:pointer;">Sphere</label>
                </div>
                <div style="display:flex; align-items:center; gap:8px;">
                    <input type="checkbox" id="bgInnerSphereCheck">
                    <label for="bgInnerSphereCheck" style="margin:0; font-size:0.7rem; color:#94a3b8; width:auto; cursor:pointer;">Inner</label>
                </div>
                <div style="display:flex; align-items:center; gap:8px;">
                    <input type="checkbox" id="bgRingCheck">
                    <label for="bgRingCheck" style="margin:0; font-size:0.7rem; color:#94a3b8; width:auto; cursor:pointer;">Ring</label>
                </div>
            </div>

            <!-- New Radius Sliders -->
            <div class="control-group">
                <label>
                    Size: Sphere
                    <span id="bgSphereSizeVal" class="value">100%</span>
                </label>
                <input type="range" id="bgSphereSizeSlider" min="50" max="150" value="100">
            </div>
            <div class="control-group">
                <label>
                    Size: Inner
                    <span id="bgInnerSizeVal" class="value">90%</span>
                </label>
                <input type="range" id="bgInnerSizeSlider" min="10" max="120" value="90">
            </div>
            <div class="control-group">
                <label>
                    Size: Ring
                    <span id="bgRingSizeVal" class="value">105%</span>
                </label>
                <input type="range" id="bgRingSizeSlider" min="50" max="150" value="105">
            </div>


            <div class="divider"></div>

            <!-- Helligkeit Modus -->
            <div class="row">
                <label for="sizeModeCheck" class="lbl-inline" style="font-weight:normal; color:#94a3b8;">Größe steuert Helligkeit</label>
                <input type="checkbox" id="sizeModeCheck">
            </div>

            <div class="divider"></div>

            <!-- Connections -->
            <div class="row">
                <div class="row-left">
                    <label for="connCheck" class="lbl-inline">Connections</label>
                    <input type="checkbox" id="connCheck">
                </div>
                <div class="row-right">
                    <label for="randConnCheck" class="lbl-sub">Random</label>
                    <input type="checkbox" id="randConnCheck">
                </div>
            </div>

            <!-- Connection Settings -->
            <div class="control-group">
                <label>
                    Connection Dist (Faktor)
                    <span id="connFactorVal" class="value">1.5x</span>
                </label>
                <input type="range" id="connFactorSlider" min="10" max="50" value="18">
            </div>
            
            <div class="control-group">
                <label>
                    Anzahl Linien (Max)
                    <span id="maxLinesVal" class="value">3</span>
                </label>
                <input type="range" id="maxLinesSlider" min="1" max="10" value="3">
            </div>

            <div class="divider"></div>

            <!-- Animation Controls -->
            <div class="row">
                <div class="row-left">
                     <label for="animCheck" class="lbl-inline">Animation</label>
                     <input type="checkbox" id="animCheck">
                </div>
            </div>

            <div class="control-group">
                <label>
                    Tempo
                    <span id="speedVal" class="value">1x</span>
                </label>
                <input type="range" id="speedSlider" min="1" max="50" value="10">
            </div>

            <div class="divider"></div>

            <!-- Export -->
            <div class="row">
                <button onclick="exportSVG()">SVG Export</button>
                <div style="display:flex; align-items:center; gap:5px;">
                    <input type="checkbox" id="bgExportCheck" checked>
                    <label for="bgExportCheck" style="margin:0; font-size:0.7rem; width:auto;">Hintergrund</label>
                </div>
            </div>
        </div>

        <!-- COLOR PANEL -->
        <div class="panel color-panel">
            <div class="row">
                <div class="row-left">
                    <label for="multiColorCheck" class="lbl-inline">Colors</label>
                    <input type="checkbox" id="multiColorCheck">
                </div>
                <div class="row-right">
                     <label for="cloudsColorCheck" class="lbl-sub">Clouds</label>
                     <input type="checkbox" id="cloudsColorCheck">

                     <label for="randColorCheck" class="lbl-sub">Random</label>
                     <input type="checkbox" id="randColorCheck">
                </div>
            </div>

            <div class="row" style="gap:5px;">
                <input type="color" id="color1" value="#00c167" title="Color 1">
                <input type="color" id="color2" value="#008cff" title="Color 2">
                <input type="color" id="color3" value="#ffa6b4" title="Color 3">
                <input type="color" id="color4" value="#822faa" title="Color 4">
            </div>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elemente
        const els = {
            anim: document.getElementById('animCheck'),
            speed: { input: document.getElementById('speedSlider'), display: document.getElementById('speedVal') },
            angle: { input: document.getElementById('angleSlider'), display: document.getElementById('angleVal') },
            crescent: { input: document.getElementById('crescentSlider'), display: document.getElementById('crescentVal') },
            hardness: { input: document.getElementById('hardnessSlider'), display: document.getElementById('hardnessVal') },
            spacing: { input: document.getElementById('spacingSlider'), display: document.getElementById('spacingVal') },
            maxSize: { input: document.getElementById('maxSizeSlider'), display: document.getElementById('maxSizeVal') },
            noise: { input: document.getElementById('noiseSlider'), display: document.getElementById('noiseVal') },
            sizeMode: document.getElementById('sizeModeCheck'),
            // Connection
            conn: document.getElementById('connCheck'),
            connRandom: document.getElementById('randConnCheck'),
            connFactor: { input: document.getElementById('connFactorSlider'), display: document.getElementById('connFactorVal') },
            maxLines: { input: document.getElementById('maxLinesSlider'), display: document.getElementById('maxLinesVal') },
            bgExport: document.getElementById('bgExportCheck'),
            // Background Sphere/Ring
            bgSphere: document.getElementById('bgSphereCheck'),
            bgInnerSphere: document.getElementById('bgInnerSphereCheck'),
            bgRing: document.getElementById('bgRingCheck'),
            // New Radius Sliders
            bgSphereSize: { input: document.getElementById('bgSphereSizeSlider'), display: document.getElementById('bgSphereSizeVal') },
            bgInnerSize: { input: document.getElementById('bgInnerSizeSlider'), display: document.getElementById('bgInnerSizeVal') },
            bgRingSize: { input: document.getElementById('bgRingSizeSlider'), display: document.getElementById('bgRingSizeVal') },

            // Color Elements
            multiColor: document.getElementById('multiColorCheck'),
            randColor: document.getElementById('randColorCheck'),
            cloudsColor: document.getElementById('cloudsColorCheck'),
            colors: [
                document.getElementById('color1'),
                document.getElementById('color2'),
                document.getElementById('color3'),
                document.getElementById('color4')
            ]
        };

        let width, height, minDim;
        const dpr = window.devicePixelRatio || 1;
        let animationFrameId;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            minDim = Math.min(width, height);
            
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            
            ctx.scale(dpr, dpr);
            if (!els.anim.checked) render();
        }

        function pseudoRandom(x, y) {
            return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
        }

        function cloudNoise(x, y) {
            const scale = 0.003;
            const v1 = Math.sin(x * scale + y * scale * 0.5);
            const v2 = Math.cos(x * scale * 0.5 - y * scale);
            const v3 = Math.sin(x * scale * 0.2 + y * scale * 0.2 + 2);
            const val = (v1 + v2 + v3) / 3; 
            return val * 0.5 + 0.5;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [0, 212, 255];
        }

        function getGradientColor(t, colors) {
            t = Math.max(0, Math.min(1, t));
            let c1, c2, localT;
            if (t < 0.33) {
                c1 = colors[0]; c2 = colors[1];
                localT = t / 0.33;
            } else if (t < 0.66) {
                c1 = colors[1]; c2 = colors[2];
                localT = (t - 0.33) / 0.33;
            } else {
                c1 = colors[2]; c2 = colors[3];
                localT = (t - 0.66) / 0.34;
            }
            const r = Math.round(c1[0] + (c2[0] - c1[0]) * localT);
            const g = Math.round(c1[1] + (c2[1] - c1[1]) * localT);
            const b = Math.round(c1[2] + (c2[2] - c1[2]) * localT);
            return [r, g, b];
        }

        // Neue Standardfarbe #00d4ff (RGB: 0, 212, 255)
        const COLOR_STD_RGB = [0, 212, 255]; 
        const COLOR_STD_HEX = "#00d4ff";

        function getPlusPathData(x, y, scale, spacing, maxSizeFactor) {
            const maxSize = spacing * maxSizeFactor; 
            const size = maxSize * scale;
            const s = size / 2;
            const t = Math.max(0.5, size * 0.15); 
            return `M ${x-t} ${y-s} L ${x+t} ${y-s} L ${x+t} ${y-t} L ${x+s} ${y-t} L ${x+s} ${y+t} L ${x+t} ${y+t} L ${x+t} ${y+s} L ${x-t} ${y+s} L ${x-t} ${y+t} L ${x-s} ${y+t} L ${x-s} ${y-t} L ${x-t} ${y-t} Z`; 
        }

        function drawSinglePathPlus(x, y, scale, spacing, sizeMode, maxSizeFactor, colorRgb) {
            ctx.beginPath();
            let drawScale = scale;
            let alpha = scale;
            if (sizeMode) {
                alpha = 1.0;
                drawScale = Math.pow(scale, 1.5); 
            }
            ctx.fillStyle = `rgba(${colorRgb[0]}, ${colorRgb[1]}, ${colorRgb[2]}, ${alpha})`;
            const maxSize = spacing * maxSizeFactor; 
            const size = maxSize * drawScale;
            const s = size / 2;
            const t = Math.max(0.5, size * 0.15); 
            ctx.moveTo(x - t, y - s); 
            ctx.lineTo(x + t, y - s); 
            ctx.lineTo(x + t, y - t); 
            ctx.lineTo(x + s, y - t); 
            ctx.lineTo(x + s, y + t); 
            ctx.lineTo(x + t, y + t); 
            ctx.lineTo(x + t, y + s); 
            ctx.lineTo(x - t, y + s); 
            ctx.lineTo(x - t, y + t); 
            ctx.lineTo(x - s, y + t); 
            ctx.lineTo(x - s, y - t); 
            ctx.lineTo(x - t, y - t); 
            ctx.closePath();
            ctx.fill();
        }

        function getRenderData() {
            const angleDeg = parseFloat(els.angle.input.value);
            const crescentFactor = parseInt(els.crescent.input.value) / 100; 
            const spacing = parseInt(els.spacing.input.value);
            const noiseFactor = parseInt(els.noise.input.value) / 100;
            const hardnessFactor = parseInt(els.hardness.input.value) / 100; 
            const maxSizeFactor = parseInt(els.maxSize.input.value) / 100; 
            const sizeMode = els.sizeMode.checked;
            
            // Connections Config
            const showConn = els.conn.checked;
            const randomConn = els.connRandom.checked;
            const connFactor = parseInt(els.connFactor.input.value) / 10; 
            const maxLines = parseInt(els.maxLines.input.value);
            const connDist = spacing * connFactor; 

            // Color Config
            const isMultiColor = els.multiColor.checked;
            const isRandomColor = els.randColor.checked;
            const isCloudsColor = els.cloudsColor.checked;
            const activeColors = els.colors.map(el => hexToRgb(el.value));

            // Background Config
            const showSphere = els.bgSphere.checked;
            const showInnerSphere = els.bgInnerSphere.checked;
            const showRing = els.bgRing.checked;

            // Größen Faktoren
            const sphereScale = parseInt(els.bgSphereSize.input.value) / 100;
            const innerSphereScale = parseInt(els.bgInnerSize.input.value) / 100;
            const ringScale = parseInt(els.bgRingSize.input.value) / 100;


            const centerX = width / 2;
            const centerY = height / 2;
            const moonRadius = minDim * 0.35; 
            
            // Berechnete Radien für die Elemente
            const sphereRadius = moonRadius * sphereScale;
            const innerSphereRadius = moonRadius * innerSphereScale;
            const ringRadius = moonRadius * ringScale;

            
            const shadowOffset = moonRadius * crescentFactor; 
            const blurFactor = 1.5 - (hardnessFactor * 1.4); 
            const blurSize = moonRadius * blurFactor;

            const angleRad = (angleDeg * Math.PI) / 180;
            const shadowX = centerX - Math.cos(angleRad) * shadowOffset;
            const shadowY = centerY - Math.sin(angleRad) * shadowOffset;

            // Für die Sphere Light Position (rotiert mit)
            const lightVecX = Math.cos(angleRad);
            const lightVecY = Math.sin(angleRad);

            const scanRadius = moonRadius + spacing + blurSize/2;
            const startCol = Math.floor((centerX - scanRadius) / spacing);
            const endCol = Math.ceil((centerX + scanRadius) / spacing);
            const startRow = Math.floor((centerY - scanRadius) / spacing);
            const endRow = Math.ceil((centerY + scanRadius) / spacing);

            let points = [];

            for (let i = startCol; i <= endCol; i++) {
                for (let j = startRow; j <= endRow; j++) {
                    const x = i * spacing;
                    const y = j * spacing;

                    const distToCenter = Math.hypot(x - centerX, y - centerY);
                    if (distToCenter > moonRadius) continue;

                    const distToShadow = Math.hypot(x - shadowX, y - shadowY);

                    let intensity = (distToShadow - (moonRadius - blurSize * 0.5)) / blurSize;
                    intensity = Math.max(0, Math.min(1, intensity));

                    if (intensity < 0.95) {
                        const rand = pseudoRandom(i, j);
                        const noiseMod = 1.0 - (hardnessFactor * 0.5); 
                        const dropoutThreshold = (1 - intensity) * noiseFactor * 2.0 * noiseMod;
                        if (rand < dropoutThreshold) continue;
                        if (noiseFactor > 0) intensity *= (1 - (rand * noiseFactor * 0.3));
                    }

                    if (intensity > 0.05) {
                        let ptColor = COLOR_STD_RGB;
                        if (isMultiColor) {
                            if (isRandomColor) {
                                const randVal = pseudoRandom(i * 13, j * 7);
                                const index = Math.floor(randVal * 4);
                                ptColor = activeColors[index];
                            } else if (isCloudsColor) {
                                const t = cloudNoise(x, y);
                                ptColor = getGradientColor(t, activeColors);
                            } else {
                                let t = x / width;
                                ptColor = getGradientColor(t, activeColors);
                            }
                        }
                        points.push({x, y, intensity, spacing, color: ptColor});
                    }
                }
            }
            return { 
                points, sizeMode, width, height, maxSizeFactor, showConn, connDist, randomConn, maxLines, 
                showSphere, showInnerSphere, showRing, moonRadius, centerX, centerY, lightVecX, lightVecY, angleRad,
                sphereRadius, innerSphereRadius, ringRadius
            };
        }

        function calculateConnections(data) {
            const lines = [];
            const maxDist = data.connDist;
            
            for (let i = 0; i < data.points.length; i++) {
                const p1 = data.points[i];
                let candidates = [];
                for (let j = i + 1; j < data.points.length; j++) {
                    const p2 = data.points[j];
                    const dx = p2.x - p1.x;
                    if (dx > maxDist) break;
                    const dy = Math.abs(p2.y - p1.y);
                    if (dy > maxDist) continue;
                    const dist = Math.hypot(dx, dy);
                    if (dist <= maxDist) candidates.push({ point: p2, dist: dist });
                }
                if (candidates.length === 0) continue;
                if (data.randomConn) {
                    candidates.sort((a, b) => {
                        const rA = pseudoRandom(p1.x + a.point.x, p1.y + a.point.y);
                        const rB = pseudoRandom(p1.x + b.point.x, p1.y + b.point.y);
                        return rA - rB;
                    });
                } else {
                    candidates.sort((a, b) => a.dist - b.dist);
                }
                const count = Math.min(candidates.length, data.maxLines);
                for(let k=0; k < count; k++) {
                    lines.push({
                        p1: p1,
                        p2: candidates[k].point,
                        opacity: (1 - candidates[k].dist / maxDist) * 0.4
                    });
                }
            }
            return lines;
        }

        function drawSphere(ctx, x, y, radius, lightVecX, lightVecY) {
            // Linearer Verlauf basierend auf Licht
            const r = radius;
            const startX = x + lightVecX * r;
            const startY = y + lightVecY * r;
            const endX = x - lightVecX * r;
            const endY = y - lightVecY * r;

            const grad = ctx.createLinearGradient(startX, startY, endX, endY);
            // Nutze Standard-Farbvariablen für Konsistenz mit Export
            grad.addColorStop(0, `rgba(${COLOR_STD_RGB.join(',')}, 0.2)`);
            grad.addColorStop(1, `rgba(${COLOR_STD_RGB.join(',')}, 0.0)`);

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
        }

        function render() {
            // UI Updates
            const angleVal = parseFloat(els.angle.input.value).toFixed(0);
            els.angle.display.innerText = angleVal + "°";
            els.crescent.display.innerText = (parseInt(els.crescent.input.value) / 100).toFixed(1);
            els.hardness.display.innerText = els.hardness.input.value + "%";
            els.spacing.display.innerText = els.spacing.input.value + "px";
            els.maxSize.display.innerText = els.maxSize.input.value + "%";
            els.noise.display.innerText = els.noise.input.value + "%";
            els.maxLines.display.innerText = els.maxLines.input.value;
            const connFact = parseInt(els.connFactor.input.value) / 10;
            els.connFactor.display.innerText = connFact.toFixed(1) + "x";
            const speed = parseInt(els.speed.input.value);
            els.speed.display.innerText = (speed / 10).toFixed(1) + "x";

            // Neue Slider Display Values
            els.bgSphereSize.display.innerText = els.bgSphereSize.input.value + "%";
            els.bgInnerSize.display.innerText = els.bgInnerSize.input.value + "%";
            els.bgRingSize.display.innerText = els.bgRingSize.input.value + "%";


            ctx.clearRect(0, 0, width, height);
            const data = getRenderData();
            
            // 0. Draw Background Sphere
            if (data.showSphere) {
                drawSphere(ctx, data.centerX, data.centerY, data.sphereRadius, data.lightVecX, data.lightVecY);
            }
            
            // 0.5 Draw Inner Sphere
            if (data.showInnerSphere) {
                drawSphere(ctx, data.centerX, data.centerY, data.innerSphereRadius, data.lightVecX, data.lightVecY);
            }
            
            // 1. Draw Connections
            if (data.showConn) {
                const lines = calculateConnections(data);
                ctx.lineWidth = 0.5;
                lines.forEach(line => {
                    ctx.beginPath();
                    const c = line.p1.color;
                    ctx.strokeStyle = `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${line.opacity})`;
                    ctx.moveTo(line.p1.x, line.p1.y);
                    ctx.lineTo(line.p2.x, line.p2.y);
                    ctx.stroke();
                });
            }

            // 2. Draw Symbols
            data.points.forEach(p => {
                drawSinglePathPlus(p.x, p.y, p.intensity, p.spacing, data.sizeMode, data.maxSizeFactor, p.color);
            });

            // 3. Draw Background Ring (Verschoben nach hinten, damit er vorne liegt)
            if (data.showRing) {
                ctx.beginPath();
                ctx.arc(data.centerX, data.centerY, data.ringRadius, 0, Math.PI * 2);
                ctx.strokeStyle = COLOR_STD_HEX; // Neue Standardfarbe
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }

        function animate() {
            if (!els.anim.checked) return;
            const speed = parseInt(els.speed.input.value);
            const increment = speed * 0.05; 
            let currentAngle = parseFloat(els.angle.input.value);
            currentAngle = (currentAngle + increment) % 360;
            els.angle.input.value = currentAngle;
            render();
            animationFrameId = requestAnimationFrame(animate);
        }

        els.anim.addEventListener('change', () => {
            if (els.anim.checked) animate();
            else if (animationFrameId) cancelAnimationFrame(animationFrameId);
        });

        function exportSVG() {
            const data = getRenderData();
            const includeBg = els.bgExport.checked;
            
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${data.width} ${data.height}" width="${data.width}px" height="${data.height}px">`;
            
            svg += `<defs>`;
            
            // Background Plane Gradient
            // Force circle via userSpaceOnUse so it doesn't skew on wide screens
            const maxDim = Math.max(data.width, data.height);
            // r should be roughly enough to cover corners. 71% of maxDim centered.
            svg += `
                <radialGradient id="bgGrad" cx="${data.width/2}" cy="${data.height/2}" r="${maxDim * 0.71}" gradientUnits="userSpaceOnUse">
                    <stop offset="0%" style="stop-color:#001e45;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#000510;stop-opacity:1" />
                </radialGradient>
            `;
            
            // Sphere Linear Gradient
            if (data.showSphere || data.showInnerSphere) {
                const cosA = Math.cos(data.angleRad);
                const sinA = Math.sin(data.angleRad);
                
                const x1 = 0.5 + cosA * 0.5;
                const y1 = 0.5 + sinA * 0.5;
                const x2 = 0.5 - cosA * 0.5;
                const y2 = 0.5 - sinA * 0.5;

                svg += `
                <linearGradient id="sphereGrad" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}">
                    <stop offset="0%" style="stop-color:${COLOR_STD_HEX};stop-opacity:0.2" />
                    <stop offset="100%" style="stop-color:${COLOR_STD_HEX};stop-opacity:0" />
                </linearGradient>
                `;
            }
            
            svg += `</defs>`;
            
            if (includeBg) {
                svg += `<rect width="100%" height="100%" fill="url(#bgGrad)"/>`;
            }

            // Export Sphere
            if (data.showSphere) {
                svg += `<circle cx="${data.centerX}" cy="${data.centerY}" r="${data.sphereRadius}" fill="url(#sphereGrad)" />`;
            }
            
            // Export Inner Sphere
            if (data.showInnerSphere) {
                svg += `<circle cx="${data.centerX}" cy="${data.centerY}" r="${data.innerSphereRadius}" fill="url(#sphereGrad)" />`;
            }

            // Connections
            if (data.showConn) {
                const lines = calculateConnections(data);
                lines.forEach(line => {
                     const op = line.opacity.toFixed(3);
                     const c = line.p1.color;
                     const colStr = `rgb(${c[0]},${c[1]},${c[2]})`;
                     svg += `<line x1="${line.p1.x}" y1="${line.p1.y}" x2="${line.p2.x}" y2="${line.p2.y}" stroke="${colStr}" stroke-opacity="${op}" stroke-width="0.5" />`;
                });
            }

            // Symbols
            data.points.forEach(p => {
                let drawScale = p.intensity;
                let opacity = p.intensity.toFixed(2);
                let fill = `rgb(${p.color[0]}, ${p.color[1]}, ${p.color[2]})`;
                if (data.sizeMode) {
                    opacity = "1";
                    drawScale = Math.pow(p.intensity, 1.5);
                }
                const d = getPlusPathData(p.x, p.y, drawScale, p.spacing, data.maxSizeFactor);
                const opacityAttr = opacity === "1" ? "" : `fill-opacity="${opacity}"`;
                svg += `<path d="${d}" fill="${fill}" ${opacityAttr} />`;
            });

            // Export Ring (Last = On Top)
            if (data.showRing) {
                svg += `<circle cx="${data.centerX}" cy="${data.centerY}" r="${data.ringRadius}" fill="none" stroke="${COLOR_STD_HEX}" stroke-width="1.5" />`;
            }

            svg += `</svg>`;
            const blob = new Blob([svg], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = `moon_pattern_${Date.now()}.svg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        window.addEventListener('resize', resize);
        function queueRender() {
            if (els.anim.checked && this !== els.anim) return; 
            render();
        }

        Object.values(els).forEach(el => {
            if (el === els.anim) return; 
            if (Array.isArray(el)) {
                el.forEach(c => c.addEventListener('input', queueRender));
            } else {
                if(el.input) el.input.addEventListener('input', queueRender);
                else el.addEventListener('change', queueRender); 
            }
        });

        setTimeout(resize, 100); 
    </script>
</body>
</html>
